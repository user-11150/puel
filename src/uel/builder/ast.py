# -*- coding: utf-8 -*-
# Auto-generated by tools/generate/gen_astnodes.py from grammer/astnodes
"""
AST nodes
"""
from typing import Protocol, runtime_checkable

@runtime_checkable
class BaseAST(Protocol):
    kind: str
    _fields: list[str]

class AST:
    kind = 'AST'
    _fields: list[str] = []

class BinOp(AST):
    kind = 'BinOp'
    _fields: list[str] = ['left', 'op', 'right', 'start', 'end']

    def __init__(self, left, op, right, start, end):
        self.left = left
        self.op = op
        self.right = right
        self.start = start
        self.end = end

class Expression(AST):
    kind = 'Expression'
    _fields: list[str] = ['value', 'start', 'end']

    def __init__(self, value, start, end):
        self.value = value
        self.start = start
        self.end = end

class Name(AST):
    kind = 'Name'
    _fields: list[str] = ['name', 'start', 'end']

    def __init__(self, name, start, end):
        self.name = name
        self.start = start
        self.end = end

class NumberLiteral(AST):
    kind = 'NumberLiteral'
    _fields: list[str] = ['value', 'start', 'end']

    def __init__(self, value, start, end):
        self.value = value
        self.start = start
        self.end = end

class StringLiteral(AST):
    kind = 'StringLiteral'
    _fields: list[str] = ['value', 'start', 'end']

    def __init__(self, value, start, end):
        self.value = value
        self.start = start
        self.end = end

class UnaryOp(AST):
    kind = 'UnaryOp'
    _fields: list[str] = ['value', 'op', 'start', 'end']

    def __init__(self, value, op, start, end):
        self.value = value
        self.op = op
        self.start = start
        self.end = end

class Module(AST):
    kind = 'Module'
    _fields: list[str] = ['body', 'start', 'end']

    def __init__(self, body, start, end):
        self.body = body
        self.start = start
        self.end = end

def dump(node: BaseAST, indent=None):

    def _format(node, level=0):
        if indent is not None:
            level += 1
            prefix = '\n' + indent * level
            sep = ',\n' + indent * level
        else:
            prefix = ''
            sep = ', '
        if isinstance(node, AST):
            args = []
            for name in node._fields:
                value = _format(getattr(node, name), level)
                args.append(f'{name}={value}')
            return f'{node.kind}({prefix}{sep.join(args)})'
        elif isinstance(node, list):
            if not node:
                return '[]'
            return f'[{prefix}{sep.join((_format(x, level) for x in node))}]'
        return repr(node)
    return _format(node)