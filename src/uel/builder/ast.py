# -*- coding: utf-8 -*-
# Auto-generated by tools/generate/gen_astnodes.py from grammer/astnodes
"""
AST nodes
"""
from typing import Protocol, runtime_checkable, Any

@runtime_checkable
class BaseAST(Protocol):
    kind: str
    _fields: list[str]
    start: Any
    end: Any

class AST:
    kind = 'AST'
    _fields: list[str] = []
    start: Any
    end: Any

class Module(AST):
    kind = 'Module'
    _fields: list[str] = ['body', 'start', 'end']

    def __init__(self, body, start, end):
        self.body = body
        self.start = start
        self.end = end

class Statement(AST):
    kind = 'Statement'
    _fields = []

class Expression(AST):
    kind = 'Expression'
    _fields = []

class Literal(Expression):
    kind = 'Literal'
    _fields = []

class Block(Statement):
    kind = 'Block'
    _fields: list[str] = ['statements', 'start', 'end']

    def __init__(self, statements, start, end):
        self.statements = statements
        self.start = start
        self.end = end

class Assign(Statement):
    kind = 'Assign'
    _fields: list[str] = ['left', 'right', 'start', 'end']

    def __init__(self, left, right, start, end):
        self.left = left
        self.right = right
        self.start = start
        self.end = end

class UnaryOp(Expression):
    kind = 'UnaryOp'
    _fields: list[str] = ['value', 'op', 'start', 'end']

    def __init__(self, value, op, start, end):
        self.value = value
        self.op = op
        self.start = start
        self.end = end

class BinOp(Expression):
    kind = 'BinOp'
    _fields: list[str] = ['left', 'op', 'right', 'start', 'end']

    def __init__(self, left, op, right, start, end):
        self.left = left
        self.op = op
        self.right = right
        self.start = start
        self.end = end

class StringLiteral(Literal):
    kind = 'StringLiteral'
    _fields: list[str] = ['value', 'start', 'end']

    def __init__(self, value, start, end):
        self.value = value
        self.start = start
        self.end = end

class NumberLiteral(Literal):
    kind = 'NumberLiteral'
    _fields: list[str] = ['value', 'start', 'end']

    def __init__(self, value, start, end):
        self.value = value
        self.start = start
        self.end = end

class Name(Expression):
    kind = 'Name'
    _fields: list[str] = ['name', 'start', 'end']

    def __init__(self, name, start, end):
        self.name = name
        self.start = start
        self.end = end

class IncludeFile(Statement):
    kind = 'IncludeFile'
    _fields: list[str] = ['filename', 'start', 'end']

    def __init__(self, filename, start, end):
        self.filename = filename
        self.start = start
        self.end = end

class ImportName(Statement):
    kind = 'ImportName'
    _fields: list[str] = ['name', 'start', 'end']

    def __init__(self, name, start, end):
        self.name = name
        self.start = start
        self.end = end

def dump(node: BaseAST, indent=None):

    def _format(node, level=0):
        if indent is not None:
            level += 1
            prefix = '\n' + indent * level
            sep = ',\n' + indent * level
        else:
            prefix = ''
            sep = ', '
        if isinstance(node, AST):
            args = []
            for name in node._fields:
                value = _format(getattr(node, name), level)
                args.append(f'{name}={value}')
            return f'{node.kind}({prefix}{sep.join(args)})'
        elif isinstance(node, list):
            if not node:
                return '[]'
            return f'[{prefix}{sep.join((_format(x, level) for x in node))}]'
        return repr(node)
    return _format(node)